# Generated by apidoc - http://www.apidoc.me
# Service version: 0.8.17
# apidoc:0.8.16 http://localhost:9000/gilt/apidoc-spec/0.8.17/ruby_client

require 'cgi'
require 'net/http'
require 'net/https'
require 'uri'
require 'base64'

require 'rubygems'
require 'json'
require 'bigdecimal'

# Specification of apidoc api.json schema
module Com
  module Gilt
    module Apidoc
      module Spec
        module V0

          class Client

            module Constants

              USER_AGENT = 'apidoc:0.8.16 http://localhost:9000/gilt/apidoc-spec/0.8.17/ruby_client' unless defined?(Constants::USER_AGENT)
              VERSION = '0.8.17' unless defined?(Constants::VERSION)
              VERSION_MAJOR = 0 unless defined?(VERSION_MAJOR)

            end

            def initialize(url, opts={})
              @url = HttpClient::Preconditions.assert_class('url', url, String)
              @authorization = HttpClient::Preconditions.assert_class_or_nil('authorization', opts.delete(:authorization), HttpClient::Authorization)
              HttpClient::Preconditions.assert_empty_opts(opts)
              HttpClient::Preconditions.check_state(url.match(/http.+/i), "URL[%s] must start with http" % url)
            end

            def request(path=nil)
              HttpClient::Preconditions.assert_class_or_nil('path', path, String)
              request = HttpClient::Request.new(URI.parse(@url + path.to_s)).with_header('User-Agent', Constants::USER_AGENT).with_header('X-Apidoc-Version', Constants::VERSION).with_header('X-Apidoc-Version-Major', Constants::VERSION_MAJOR)

              if @authorization
                request.with_auth(@authorization)
              else
                request
              end
            end


          end

          module Clients



          end

          module Models

            class Method

              attr_reader :value

              def initialize(value)
                @value = HttpClient::Preconditions.assert_class('value', value, String)
              end

              # Returns the instance of Method for this value, creating a new instance for an unknown value
              def Method.apply(value)
                if value.instance_of?(Method)
                  value
                else
                  HttpClient::Preconditions.assert_class_or_nil('value', value, String)
                  value.nil? ? nil : (from_string(value) || Method.new(value))
                end
              end

              # Returns the instance of Method for this value, or nil if not found
              def Method.from_string(value)
                HttpClient::Preconditions.assert_class('value', value, String)
                Method.ALL.find { |v| v.value == value }
              end

              def Method.ALL
                @@all ||= [Method.get, Method.post, Method.put, Method.patch, Method.delete, Method.head, Method.connect, Method.options, Method.trace]
              end

              def Method.get
                @@_get ||= Method.new('GET')
              end

              def Method.post
                @@_post ||= Method.new('POST')
              end

              def Method.put
                @@_put ||= Method.new('PUT')
              end

              def Method.patch
                @@_patch ||= Method.new('PATCH')
              end

              def Method.delete
                @@_delete ||= Method.new('DELETE')
              end

              def Method.head
                @@_head ||= Method.new('HEAD')
              end

              def Method.connect
                @@_connect ||= Method.new('CONNECT')
              end

              def Method.options
                @@_options ||= Method.new('OPTIONS')
              end

              def Method.trace
                @@_trace ||= Method.new('TRACE')
              end

              def to_hash
                value
              end

            end

            class ParameterLocation

              attr_reader :value

              def initialize(value)
                @value = HttpClient::Preconditions.assert_class('value', value, String)
              end

              # Returns the instance of ParameterLocation for this value, creating a new instance for an unknown value
              def ParameterLocation.apply(value)
                if value.instance_of?(ParameterLocation)
                  value
                else
                  HttpClient::Preconditions.assert_class_or_nil('value', value, String)
                  value.nil? ? nil : (from_string(value) || ParameterLocation.new(value))
                end
              end

              # Returns the instance of ParameterLocation for this value, or nil if not found
              def ParameterLocation.from_string(value)
                HttpClient::Preconditions.assert_class('value', value, String)
                ParameterLocation.ALL.find { |v| v.value == value }
              end

              def ParameterLocation.ALL
                @@all ||= [ParameterLocation.path, ParameterLocation.query, ParameterLocation.form]
              end

              def ParameterLocation.path
                @@_path ||= ParameterLocation.new('Path')
              end

              def ParameterLocation.query
                @@_query ||= ParameterLocation.new('Query')
              end

              def ParameterLocation.form
                @@_form ||= ParameterLocation.new('Form')
              end

              def to_hash
                value
              end

            end

            class Application

              attr_reader :key

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Application.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :key => key
                }
              end

            end

            class Body

              attr_reader :type, :description

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @type = HttpClient::Preconditions.assert_class('type', opts.delete(:type), String)
                @description = HttpClient::Preconditions.assert_class_or_nil('description', opts.delete(:description), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Body.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :type => type,
                  :description => description
                }
              end

            end

            class Enum

              attr_reader :name, :plural, :description, :values

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
                @plural = HttpClient::Preconditions.assert_class('plural', opts.delete(:plural), String)
                @description = HttpClient::Preconditions.assert_class_or_nil('description', opts.delete(:description), String)
                @values = HttpClient::Preconditions.assert_class('values', opts.delete(:values), Array).map { |el| el.nil? ? nil : (el.is_a?(::Com::Gilt::Apidoc::Spec::V0::Models::EnumValue) ? el : ::Com::Gilt::Apidoc::Spec::V0::Models::EnumValue.new(el)) }
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Enum.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :name => name,
                  :plural => plural,
                  :description => description,
                  :values => (values || []).map(&:to_hash)
                }
              end

            end

            class EnumValue

              attr_reader :name, :description

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
                @description = HttpClient::Preconditions.assert_class_or_nil('description', opts.delete(:description), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                EnumValue.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :name => name,
                  :description => description
                }
              end

            end

            class Field

              attr_reader :name, :type, :description, :default, :required, :minimum, :maximum, :example

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
                @type = HttpClient::Preconditions.assert_class('type', opts.delete(:type), String)
                @description = HttpClient::Preconditions.assert_class_or_nil('description', opts.delete(:description), String)
                @default = HttpClient::Preconditions.assert_class_or_nil('default', opts.delete(:default), String)
                @required = HttpClient::Preconditions.assert_boolean('required', opts.delete(:required))
                @minimum = HttpClient::Preconditions.assert_class_or_nil('minimum', opts.delete(:minimum), Integer)
                @maximum = HttpClient::Preconditions.assert_class_or_nil('maximum', opts.delete(:maximum), Integer)
                @example = HttpClient::Preconditions.assert_class_or_nil('example', opts.delete(:example), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Field.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :name => name,
                  :type => type,
                  :description => description,
                  :default => default,
                  :required => required,
                  :minimum => minimum,
                  :maximum => maximum,
                  :example => example
                }
              end

            end

            class Header

              attr_reader :name, :type, :description, :required, :default

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
                @type = HttpClient::Preconditions.assert_class('type', opts.delete(:type), String)
                @description = HttpClient::Preconditions.assert_class_or_nil('description', opts.delete(:description), String)
                @required = HttpClient::Preconditions.assert_boolean('required', opts.delete(:required))
                @default = HttpClient::Preconditions.assert_class_or_nil('default', opts.delete(:default), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Header.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :name => name,
                  :type => type,
                  :description => description,
                  :required => required,
                  :default => default
                }
              end

            end

            # An import is used to declare a dependency on another application. This allows
            # you to reference the models and or enums from that application in your own
            # app.
            class Import

              attr_reader :uri, :namespace, :organization, :application, :version, :enums, :unions, :models

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @uri = HttpClient::Preconditions.assert_class('uri', opts.delete(:uri), String)
                @namespace = HttpClient::Preconditions.assert_class('namespace', opts.delete(:namespace), String)
                @organization = HttpClient::Preconditions.assert_class('organization', opts[:organization].nil? ? nil : (opts[:organization].is_a?(::Com::Gilt::Apidoc::Spec::V0::Models::Organization) ? opts.delete(:organization) : ::Com::Gilt::Apidoc::Spec::V0::Models::Organization.new(opts.delete(:organization))), ::Com::Gilt::Apidoc::Spec::V0::Models::Organization)
                @application = HttpClient::Preconditions.assert_class('application', opts[:application].nil? ? nil : (opts[:application].is_a?(::Com::Gilt::Apidoc::Spec::V0::Models::Application) ? opts.delete(:application) : ::Com::Gilt::Apidoc::Spec::V0::Models::Application.new(opts.delete(:application))), ::Com::Gilt::Apidoc::Spec::V0::Models::Application)
                @version = HttpClient::Preconditions.assert_class('version', opts.delete(:version), String)
                @enums = HttpClient::Preconditions.assert_class('enums', opts.delete(:enums), Array).map { |v| HttpClient::Preconditions.assert_class('enums', v, String)}
                @unions = HttpClient::Preconditions.assert_class('unions', opts.delete(:unions), Array).map { |v| HttpClient::Preconditions.assert_class('unions', v, String)}
                @models = HttpClient::Preconditions.assert_class('models', opts.delete(:models), Array).map { |v| HttpClient::Preconditions.assert_class('models', v, String)}
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Import.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :uri => uri,
                  :namespace => namespace,
                  :organization => organization.nil? ? nil : organization.to_hash,
                  :application => application.nil? ? nil : application.to_hash,
                  :version => version,
                  :enums => enums,
                  :unions => unions,
                  :models => models
                }
              end

            end

            class Model

              attr_reader :name, :plural, :description, :fields

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
                @plural = HttpClient::Preconditions.assert_class('plural', opts.delete(:plural), String)
                @description = HttpClient::Preconditions.assert_class_or_nil('description', opts.delete(:description), String)
                @fields = HttpClient::Preconditions.assert_class('fields', opts.delete(:fields), Array).map { |el| el.nil? ? nil : (el.is_a?(::Com::Gilt::Apidoc::Spec::V0::Models::Field) ? el : ::Com::Gilt::Apidoc::Spec::V0::Models::Field.new(el)) }
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Model.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :name => name,
                  :plural => plural,
                  :description => description,
                  :fields => (fields || []).map(&:to_hash)
                }
              end

            end

            class Operation

              attr_reader :method, :path, :description, :body, :parameters, :responses

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @method = HttpClient::Preconditions.assert_class('method', opts[:method].nil? ? nil : (opts[:method].is_a?(::Com::Gilt::Apidoc::Spec::V0::Models::Method) ? opts.delete(:method) : ::Com::Gilt::Apidoc::Spec::V0::Models::Method.apply(opts.delete(:method))), ::Com::Gilt::Apidoc::Spec::V0::Models::Method)
                @path = HttpClient::Preconditions.assert_class('path', opts.delete(:path), String)
                @description = HttpClient::Preconditions.assert_class_or_nil('description', opts.delete(:description), String)
                @body = HttpClient::Preconditions.assert_class_or_nil('body', opts[:body].nil? ? nil : (opts[:body].is_a?(::Com::Gilt::Apidoc::Spec::V0::Models::Body) ? opts.delete(:body) : ::Com::Gilt::Apidoc::Spec::V0::Models::Body.new(opts.delete(:body))), ::Com::Gilt::Apidoc::Spec::V0::Models::Body)
                @parameters = (opts.delete(:parameters) || []).map { |el| el.nil? ? nil : (el.is_a?(::Com::Gilt::Apidoc::Spec::V0::Models::Parameter) ? el : ::Com::Gilt::Apidoc::Spec::V0::Models::Parameter.new(el)) }
                @responses = (opts.delete(:responses) || []).map { |el| el.nil? ? nil : (el.is_a?(::Com::Gilt::Apidoc::Spec::V0::Models::Response) ? el : ::Com::Gilt::Apidoc::Spec::V0::Models::Response.new(el)) }
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Operation.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :method => method.nil? ? nil : method.value,
                  :path => path,
                  :description => description,
                  :body => body.nil? ? nil : body.to_hash,
                  :parameters => (parameters || []).map(&:to_hash),
                  :responses => (responses || []).map(&:to_hash)
                }
              end

            end

            class Organization

              attr_reader :key

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Organization.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :key => key
                }
              end

            end

            class Parameter

              attr_reader :name, :type, :location, :description, :required, :default, :minimum, :maximum, :example

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
                @type = HttpClient::Preconditions.assert_class('type', opts.delete(:type), String)
                @location = HttpClient::Preconditions.assert_class('location', opts[:location].nil? ? nil : (opts[:location].is_a?(::Com::Gilt::Apidoc::Spec::V0::Models::ParameterLocation) ? opts.delete(:location) : ::Com::Gilt::Apidoc::Spec::V0::Models::ParameterLocation.apply(opts.delete(:location))), ::Com::Gilt::Apidoc::Spec::V0::Models::ParameterLocation)
                @description = HttpClient::Preconditions.assert_class_or_nil('description', opts.delete(:description), String)
                @required = HttpClient::Preconditions.assert_boolean('required', opts.delete(:required))
                @default = HttpClient::Preconditions.assert_class_or_nil('default', opts.delete(:default), String)
                @minimum = HttpClient::Preconditions.assert_class_or_nil('minimum', opts.delete(:minimum), Integer)
                @maximum = HttpClient::Preconditions.assert_class_or_nil('maximum', opts.delete(:maximum), Integer)
                @example = HttpClient::Preconditions.assert_class_or_nil('example', opts.delete(:example), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Parameter.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :name => name,
                  :type => type,
                  :location => location.nil? ? nil : location.value,
                  :description => description,
                  :required => required,
                  :default => default,
                  :minimum => minimum,
                  :maximum => maximum,
                  :example => example
                }
              end

            end

            class Resource

              attr_reader :type, :plural, :description, :operations

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @type = HttpClient::Preconditions.assert_class('type', opts.delete(:type), String)
                @plural = HttpClient::Preconditions.assert_class('plural', opts.delete(:plural), String)
                @description = HttpClient::Preconditions.assert_class_or_nil('description', opts.delete(:description), String)
                @operations = HttpClient::Preconditions.assert_class('operations', opts.delete(:operations), Array).map { |el| el.nil? ? nil : (el.is_a?(::Com::Gilt::Apidoc::Spec::V0::Models::Operation) ? el : ::Com::Gilt::Apidoc::Spec::V0::Models::Operation.new(el)) }
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Resource.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :type => type,
                  :plural => plural,
                  :description => description,
                  :operations => (operations || []).map(&:to_hash)
                }
              end

            end

            class Response

              attr_reader :code, :type

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), Integer)
                @type = HttpClient::Preconditions.assert_class('type', opts.delete(:type), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Response.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :code => code,
                  :type => type
                }
              end

            end

            class Service

              attr_reader :name, :organization, :application, :namespace, :version, :base_url, :description, :headers, :imports, :enums, :unions, :models, :resources

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
                @organization = HttpClient::Preconditions.assert_class('organization', opts[:organization].nil? ? nil : (opts[:organization].is_a?(::Com::Gilt::Apidoc::Spec::V0::Models::Organization) ? opts.delete(:organization) : ::Com::Gilt::Apidoc::Spec::V0::Models::Organization.new(opts.delete(:organization))), ::Com::Gilt::Apidoc::Spec::V0::Models::Organization)
                @application = HttpClient::Preconditions.assert_class('application', opts[:application].nil? ? nil : (opts[:application].is_a?(::Com::Gilt::Apidoc::Spec::V0::Models::Application) ? opts.delete(:application) : ::Com::Gilt::Apidoc::Spec::V0::Models::Application.new(opts.delete(:application))), ::Com::Gilt::Apidoc::Spec::V0::Models::Application)
                @namespace = HttpClient::Preconditions.assert_class('namespace', opts.delete(:namespace), String)
                @version = HttpClient::Preconditions.assert_class('version', opts.delete(:version), String)
                @base_url = HttpClient::Preconditions.assert_class_or_nil('base_url', opts.delete(:base_url), String)
                @description = HttpClient::Preconditions.assert_class_or_nil('description', opts.delete(:description), String)
                @headers = HttpClient::Preconditions.assert_class('headers', opts.delete(:headers), Array).map { |el| el.nil? ? nil : (el.is_a?(::Com::Gilt::Apidoc::Spec::V0::Models::Header) ? el : ::Com::Gilt::Apidoc::Spec::V0::Models::Header.new(el)) }
                @imports = HttpClient::Preconditions.assert_class('imports', opts.delete(:imports), Array).map { |el| el.nil? ? nil : (el.is_a?(::Com::Gilt::Apidoc::Spec::V0::Models::Import) ? el : ::Com::Gilt::Apidoc::Spec::V0::Models::Import.new(el)) }
                @enums = HttpClient::Preconditions.assert_class('enums', opts.delete(:enums), Array).map { |el| el.nil? ? nil : (el.is_a?(::Com::Gilt::Apidoc::Spec::V0::Models::Enum) ? el : ::Com::Gilt::Apidoc::Spec::V0::Models::Enum.new(el)) }
                @unions = HttpClient::Preconditions.assert_class('unions', opts.delete(:unions), Array).map { |el| el.nil? ? nil : (el.is_a?(::Com::Gilt::Apidoc::Spec::V0::Models::Union) ? el : ::Com::Gilt::Apidoc::Spec::V0::Models::Union.new(el)) }
                @models = HttpClient::Preconditions.assert_class('models', opts.delete(:models), Array).map { |el| el.nil? ? nil : (el.is_a?(::Com::Gilt::Apidoc::Spec::V0::Models::Model) ? el : ::Com::Gilt::Apidoc::Spec::V0::Models::Model.new(el)) }
                @resources = HttpClient::Preconditions.assert_class('resources', opts.delete(:resources), Array).map { |el| el.nil? ? nil : (el.is_a?(::Com::Gilt::Apidoc::Spec::V0::Models::Resource) ? el : ::Com::Gilt::Apidoc::Spec::V0::Models::Resource.new(el)) }
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Service.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :name => name,
                  :organization => organization.nil? ? nil : organization.to_hash,
                  :application => application.nil? ? nil : application.to_hash,
                  :namespace => namespace,
                  :version => version,
                  :base_url => base_url,
                  :description => description,
                  :headers => (headers || []).map(&:to_hash),
                  :imports => (imports || []).map(&:to_hash),
                  :enums => (enums || []).map(&:to_hash),
                  :unions => (unions || []).map(&:to_hash),
                  :models => (models || []).map(&:to_hash),
                  :resources => (resources || []).map(&:to_hash)
                }
              end

            end

            class Union

              attr_reader :name, :plural, :description, :types

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
                @plural = HttpClient::Preconditions.assert_class('plural', opts.delete(:plural), String)
                @description = HttpClient::Preconditions.assert_class_or_nil('description', opts.delete(:description), String)
                @types = HttpClient::Preconditions.assert_class('types', opts.delete(:types), Array).map { |el| el.nil? ? nil : (el.is_a?(::Com::Gilt::Apidoc::Spec::V0::Models::UnionType) ? el : ::Com::Gilt::Apidoc::Spec::V0::Models::UnionType.new(el)) }
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Union.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :name => name,
                  :plural => plural,
                  :description => description,
                  :types => (types || []).map(&:to_hash)
                }
              end

            end

            # Metadata about one of the types that is part of a union type
            class UnionType

              attr_reader :type, :description

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @type = HttpClient::Preconditions.assert_class('type', opts.delete(:type), String)
                @description = HttpClient::Preconditions.assert_class_or_nil('description', opts.delete(:description), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                UnionType.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :type => type,
                  :description => description
                }
              end

            end

          end

          # ===== END OF SERVICE DEFINITION =====
          module HttpClient

            class Request

              def initialize(uri)
                @uri = Preconditions.assert_class('uri', uri, URI)
                @params = nil
                @body = nil
                @auth = nil
                @headers = {}
                @header_keys_lower_case = []
              end

              def with_header(name, value)
                Preconditions.check_not_blank('name', name, "Header name is required")
                Preconditions.check_not_blank('value', value, "Header value is required")
                Preconditions.check_state(!@headers.has_key?(name),
                                          "Duplicate header named[%s]" % name)
                @headers[name] = value
                @header_keys_lower_case << name.downcase
                self
              end

              def with_auth(auth)
                Preconditions.assert_class('auth', auth, HttpClient::Authorization)
                Preconditions.check_state(@auth.nil?, "auth previously set")

                if auth.scheme.name == AuthScheme::BASIC.name
                  @auth = auth
                else
                  raise "Auth Scheme[#{auth.scheme.name}] not supported"
                end
                self
              end

              def with_query(params)
                Preconditions.assert_class('params', params, Hash)
                Preconditions.check_state(@params.nil?, "Already have query parameters")
                @params = params
                self
              end

              # Wrapper to set Content-Type header to application/json and set
              # the provided json document as the body
              def with_json(json)
                @headers['Content-Type'] ||= 'application/json; charset=UTF-8'
                with_body(json)
              end

              def with_body(body)
                Preconditions.check_not_blank('body', body)
                @body = body
                self
              end

              # Creates a new Net:HTTP client. The client returned should be
              # fully configured to make a request.
              def new_http_client
                client = Net::HTTP.new(@uri.host, @uri.port)
                if @uri.scheme == "https"
                  configure_ssl(client)
                end
                client
              end

              # If HTTP is required, this method accepts an HTTP Client and configures SSL
              def configure_ssl(client)
                Preconditions.assert_class('client', client, Net::HTTP)
                client.use_ssl = true
                client.verify_mode = OpenSSL::SSL::VERIFY_PEER
                client.cert_store = OpenSSL::X509::Store.new
                client.cert_store.set_default_paths
              end

              def get(&block)
                do_request(Net::HTTP::Get, &block)
              end

              def delete(&block)
                do_request(Net::HTTP::Delete, &block)
              end

              def options(&block)
                do_request(Net::HTTP::Options, &block)
              end

              def post(&block)
                do_request(Net::HTTP::Post, &block)
              end

              def put(&block)
                do_request(Net::HTTP::Put, &block)
              end

              class PATCH < Net::HTTP::Put
                METHOD = "PATCH"
              end

              def patch(&block)
                do_request(PATCH, &block)
              end

              def do_request(klass)
                Preconditions.assert_class('klass', klass, Class)

                uri = @uri.to_s
                if q = to_query(@params)
                  uri += "?%s" % q
                end

                request = klass.send(:new, uri)

                curl = ['curl']
                if klass != Net::HTTP::Get
                  curl << "-X%s" % klass.name.split("::").last.upcase
                end

                if @body
                  # DEBUG path = "/tmp/rest_client.tmp"
                  # DEBUG File.open(path, "w") { |os| os << @body.to_s }
                  # DEBUG curl << "-d@%s" % path
                  request.body = @body
                end

                if @auth
                  curl << "-u \"%s:%s\"" % [@auth.username, @auth.password]
                  Preconditions.check_state(!@header_keys_lower_case.include?("authorization"),
                                            "Cannot specify both an Authorization header and an auth instance")
                  user_pass = "%s:%s" % [@auth.username, @auth.password]
                  encoded = Base64.encode64(user_pass).to_s.split("\n").map(&:strip).join
                  request.add_field("Authorization", "Basic %s" % encoded)
                end

                @headers.each { |key, value|
                  curl <<  "-H \"%s: %s\"" % [key, value]
                  request.add_field(key, value)
                }

                curl << "'%s'" % uri
                # DEBUG puts curl.join(" ")

                raw_response = http_request(request)
                response = raw_response.to_s == "" ? nil : JSON.parse(raw_response)

                if block_given?
                  yield response
                else
                  response
                end
              end

              private
              def to_query(params={})
                parts = (params || {}).map { |k,v|
                  if v.respond_to?(:each)
                    v.map { |el| "%s=%s" % [k, CGI.escape(el.to_s)] }
                  else
                    "%s=%s" % [k, CGI.escape(v.to_s)]
                  end
                }
                parts.empty? ? nil : parts.join("&")
              end

              def http_request(request)
                response = new_http_client.request(request)

                case response
                when Net::HTTPSuccess
                  response.body
                else
                  body = response.body rescue nil
                  raise HttpClient::ServerError.new(response.code.to_i, response.message, :body => body)
                end
              end
            end

            class ServerError < StandardError

              attr_reader :code, :details, :body

              def initialize(code, details, incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @code = HttpClient::Preconditions.assert_class('code', code, Integer)
                @details = HttpClient::Preconditions.assert_class('details', details, String)
                @body = HttpClient::Preconditions.assert_class_or_nil('body', opts.delete(:body), String)
                HttpClient::Preconditions.assert_empty_opts(opts)
                super(self.message)
              end

              def message
                m = "%s %s" % [@code, @details]
                if @body
                  m << ": %s" % @body
                end
                m
              end

              def body_json
                JSON.parse(@body)
              end

            end

            module Preconditions

              def Preconditions.check_argument(expression, error_message=nil)
                if !expression
                  raise error_message || "check_argument failed"
                end
                nil
              end

              def Preconditions.check_state(expression, error_message=nil)
                if !expression
                  raise error_message || "check_state failed"
                end
                nil
              end

              def Preconditions.check_not_nil(field_name, reference, error_message=nil)
                if reference.nil?
                  raise error_message || "argument for %s cannot be nil" % field_name
                end
                reference
              end

              def Preconditions.check_not_blank(field_name, reference, error_message=nil)
                if reference.to_s.strip == ""
                  raise error_message || "argument for %s cannot be blank" % field_name
                end
                reference
              end

              # Throws an error if opts is not empty. Useful when parsing
              # arguments to a function
              def Preconditions.assert_empty_opts(opts)
                if !opts.empty?
                  raise "Invalid opts: #{opts.keys.inspect}\n#{opts.inspect}"
                end
              end

              # Asserts that value is not nill and is_?(klass). Returns
              # value. Common use is
              #
              # amount = Preconditions.assert_class('amount', amount, BigDecimal)
              def Preconditions.assert_class(field_name, value, klass)
                Preconditions.check_not_nil('field_name', field_name)
                Preconditions.check_not_nil('klass', klass)
                Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of class %s" % [field_name, klass.name])
                Preconditions.check_state(value.is_a?(klass),
                                          "Value for #{field_name} is of type[#{value.class}] - class[#{klass}] is required. value[#{value.inspect.to_s}]")
                value
              end

              def Preconditions.assert_class_or_nil(field_name, value, klass)
                if !value.nil?
                  Preconditions.assert_class(field_name, value, klass)
                end
              end

              def Preconditions.assert_boolean(field_name, value)
                Preconditions.check_not_nil('field_name', field_name)
                Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of TrueClass or FalseClass" % field_name)
                Preconditions.check_state(value.is_a?(TrueClass) || value.is_a?(FalseClass),
                                          "Value for #{field_name} is of type[#{value.class}] - class[TrueClass or FalseClass] is required. value[#{value.inspect.to_s}]")
                value
              end

              def Preconditions.assert_boolean_or_nil(field_name, value)
                if !value.nil?
                  Preconditions.assert_boolean(field_name, value)
                end
              end

              def Preconditions.assert_collection_of_class(field_name, values, klass)
                Preconditions.assert_class(field_name, values, Array)
                values.each { |v| Preconditions.assert_class(field_name, v, klass) }
              end

              def Preconditions.assert_hash_of_class(field_name, hash, klass)
                Preconditions.assert_class(field_name, hash, Hash)
                values.each { |k, v| Preconditions.assert_class(field_name, v, klass) }
              end

            end

            class AuthScheme

              attr_reader :name

              def initialize(name)
                @name = HttpClient::Preconditions.check_not_blank('name', name)
              end

              BASIC = AuthScheme.new("basic") unless defined?(BASIC)

            end

            class Authorization

              attr_reader :scheme, :username, :password

              def initialize(scheme, username, opts={})
                @scheme = HttpClient::Preconditions.assert_class('schema', scheme, AuthScheme)
                @username = HttpClient::Preconditions.check_not_blank('username', username, "username is required")
                @password = HttpClient::Preconditions.assert_class_or_nil('password', opts.delete(:password), String)
                HttpClient::Preconditions.assert_empty_opts(opts)
              end

              def Authorization.basic(username, password=nil)
                Authorization.new(AuthScheme::BASIC, username, :password => password)
              end

            end

            module Helper

              def Helper.symbolize_keys(hash)
                Preconditions.assert_class('hash', hash, Hash)
                new_hash = {}
                hash.each { |k, v|
                  new_hash[k.to_sym] = v
                }
                new_hash
              end

              def Helper.to_big_decimal(value)
                value ? BigDecimal.new(value.to_s) : nil
              end

              def Helper.to_object(value)
                value ? JSON.parse(value) : nil
              end

              def Helper.to_uuid(value)
                Preconditions.check_state(value.nil? || value.match(/^\w\w\w\w\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\w\w\w\w\w\w\w\w$/),
                                          "Invalid guid[%s]" % value)
                value
              end

              def Helper.to_date_iso8601(value)
                if value.is_a?(Date)
                  value
                elsif value
                  Date.parse(value.to_s)
                else
                  nil
                end
              end

              def Helper.to_date_time_iso8601(value)
                if value.is_a?(DateTime)
                  value
                elsif value
                  DateTime.parse(value.to_s)
                else
                  nil
                end
              end

              def Helper.date_iso8601_to_string(value)
                value.nil? ? nil : value.strftime('%Y-%m-%d')
              end

              def Helper.date_time_iso8601_to_string(value)
                value.nil? ? nil : value.strftime('%Y-%m-%dT%H:%M:%S%z')
              end

              TRUE_STRINGS = ['t', 'true', 'y', 'yes', 'on', '1', 'trueclass'] unless defined?(TRUE_STRINGS)
              FALSE_STRINGS = ['f', 'false', 'n', 'no', 'off', '0', 'falseclass'] unless defined?(FALSE_STRINGS)

              def Helper.to_boolean(field_name, value)
                string = value.to_s.strip.downcase
                if TRUE_STRINGS.include?(string)
                  true
                elsif FALSE_STRINGS.include?(string)
                  false
                elsif string != ""
                  raise "Unsupported boolean value[#{string}]. For true, must be one of: #{TRUE_STRINGS.inspect}. For false, must be one of: #{FALSE_STRINGS.inspect}"
                else
                  nil
                end
              end

            end

          end
        end
      end
    end
  end
end