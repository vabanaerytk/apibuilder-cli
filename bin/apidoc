#!/usr/bin/env ruby

# CLI to apidoc
#
# Usage:
#  apidoc-cli <command> <arguments>
#  PROFILE=gilt apidoc-cli <command> <arguments>
#
# Environment variables:
#    PROFILE: will default to the 'default' specified in your configuration file
#
# The arguments vary by the command
#
# apidoc-cli list organizations
#  - Returns a list of all of the organizations that you have access to
#  - Pagination is implemented with environment variables LIMIT and OFFSET. Example:
#    LIMIT=10 OFFSET=0 apidoc-cli list organizations
#
# apidoc-cli list applications gilt
#  - Returns a list of the applications for the organization gilt
#  - Pagination is implemented with environment variables LIMIT and OFFSET. Example:
#    LIMIT=10 OFFSET=0 apidoc-cli list applications gilt
#
# apidoc-cli list versions gilt apidoc
#  - Returns a list of all of the versions for the specific org and application.
#  - Pagination is implemented with environment variables LIMIT and OFFSET. Example:
#    LIMIT=10 OFFSET=0 apidoc-cli list applications gilt
#
# apidoc-cli code gilt apidoc latest scala_models
#  - Returns the code for gilt/apidoc version 'latest' using the
#    codegenerator 'scala_models'
#
# apidoc-cli upload gilt apidoc api/api.json [--version 1.5.0-dev]
#  - Uploads the file api/api.json to the gilt org, apidoc application.
#    The uploaded file will be the specified version, defaulting to
#    the output from git describe.
#
# apidoc-cli update [--path path]
#  - Reads a config file, optionally specified by path
#    parameter. Invokes the apidoc code generators specified in the
#    configuration file.
#

load File.join(File.dirname(__FILE__), 'apidoc-cli-config')

env = {
  :profile => ApidocCli::Util.read_non_empty_string(ENV['PROFILE']),
  :limit => ApidocCli::Util.read_non_empty_integer(ENV['LIMIT']),
  :offset => ApidocCli::Util.read_non_empty_integer(ENV['OFFSET'])
}

client = ApidocCli::Config.client_from_profile(:profile => env[:profile])

command = ARGV.shift.to_s.strip

if command == "list"
  resource = ARGV.shift.to_s.strip

  if resource == "organizations"
    client.organizations.get(:limit => env[:limit], :offset => env[:offset]).each do |org|
      puts org.key
    end

  elsif resource == "applications"
    org = ARGV.shift.to_s.strip

    if org == ""
      puts "organization is required"
      exit(1)
    else
      client.applications.get_by_org_key(org, :limit => env[:limit], :offset => env[:offset]).each do |app|
        puts app.key
      end
    end

  elsif resource == "versions"
    org = ARGV.shift.to_s.strip
    application = ARGV.shift.to_s.strip

    if org == "" || application == ""
      puts "organization and application are required"
      exit(1)
    else
      client.versions.get_by_org_key_and_application_key(org, application, :limit => env[:limit], :offset => env[:offset]).each do |v|
        puts v.version
      end
    end

  elsif resource == ""
    puts "resource to list is required"
    exit(1)

  else
    puts "unrecognized resource[#{resource}]"
    exit(1)
  end

elsif command == "code"
  org = ARGV.shift.to_s.strip
  application = ARGV.shift.to_s.strip
  version = ARGV.shift.to_s.strip
  generator = ARGV.shift.to_s.strip

  if org == "" || application == "" || version == "" || generator == ""
    puts "org, application, version, and generator are required"
    exit(1)
  end

  code = client.code.get_by_org_key_and_application_key_and_version_and_generator_key(org, application, version, generator)
  puts code.source

elsif command == "upload"
  org = ARGV.shift.to_s.strip
  application = ARGV.shift.to_s.strip
  path = ARGV.shift.to_s.strip

  args = ApidocCli::Args.parse(ARGV)
  version = args[:version].to_s.strip

  if org == "" || application == "" || path == ""
    puts "org, application, path are required"
    exit(1)
  end

  if !File.exists?(path)
    puts "File[#{path}] does not exist"
    exit(1)
  end

  if version == ""
    default_version = `git describe`.strip

    print "Version"
    if default_version != ""
      print " [#{default_version}]"
    end
    print ": "

    version = nil
    while version.nil?
      answer = $stdin.gets
      if answer.strip == "" && default_version != ""
        version = default_version
      else
        version = answer.strip
      end
    end
  end

  original_form = Com::Gilt::Apidoc::Api::V0::Models::OriginalForm.new(:data => IO.read(path))
  form = Com::Gilt::Apidoc::Api::V0::Models::VersionForm.new(:original_form => original_form)

  # TODO: Upload want to upload this version if it is different from
  # the last uploaded version. should be able to download 'latest'
  # version and do a string compare to "original" attribute.
  begin
    existing = client.versions.get_by_org_key_and_application_key_and_version(org, application, "latest")
    tmp = "/tmp/foo.json"
    ApidocCli::Util.write_to_file(tmp, existing.original)
    puts "Wrote original to #{tmp}" # TODO: Test if same somehow
  rescue Com::Gilt::Apidoc::Api::V0::HttpClient::ServerError => e
    if e.code == 404
      # We don't have any versions
    else
      raise e
    end
  end

  print "Uploading #{path} to #{client.uri}/#{org}/#{application}/#{version} ... "
  begin
    client.versions.put_by_org_key_and_application_key_and_version(org, application, version, form)
    puts "success"
  rescue Com::Gilt::Apidoc::Api::V0::HttpClient::ServerError => e
    puts "1 or more errors:"
    JSON.parse(e.body).each do |error|
      if error['code'] == "validation_error"
        puts " - %s" % error['message']
      else
        puts " - %s: %s" % [error['code'], error['message']]
      end
    end
  end

elsif command == "update"
  args = ApidocCli::Args.parse(ARGV)
  path = File.expand_path(args[:path] || ApidocCli::AppConfig::DEFAULT_FILENAME)

  if !File.exists?(path)
    puts "File #{path} does not exit"
    exit(1)
  end

  target_dir = File.dirname(path)

  updates = []
  puts "Fetching code from #{client.uri}"

  app_config = ApidocCli::AppConfig.new(:path => path)

  app_config.code.projects.map do |project|
    project.generators.each do |generator|
      target_path = File.join(target_dir, generator.target)
      print "  - #{project.org}/#{project.name}/#{project.version}/#{generator.name} ... "

      begin
        code = client.code.get_by_org_key_and_application_key_and_version_and_generator_key(project.org, project.name, project.version, generator.name)
        source = code.source.strip

        existing_source = File.exists?(target_path) ? IO.read(target_path).strip : ""
        if source == existing_source
          puts "unchanged"
        else
          puts "changed"
          updates << { :source => source, :generator => generator.name, :target => target_path }
        end
      rescue Com::Gilt::Apidoc::Api::V0::HttpClient::ServerError => e
        if e.code == 404
          puts "not found"
        else
          puts ""
          raise e
        end
      end
    end
  end

  puts ""
  if !updates.empty?
    puts "Copying updated code"
    updates.each do |data|
      puts " - #{data[:generator]} => #{data[:target]}"
      ApidocCli::Util.write_to_file(data[:target], data[:source])
    end
  end

elsif command == ""
  puts "command is required"
  exit(1)

else
  puts "unrecognized command[#{command}]"
  exit(1)
end
